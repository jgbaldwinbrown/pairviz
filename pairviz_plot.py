#!/usr/bin/env python3

import os

os.environ["PATH"] = "/usr/local/bin:/usr/local/anaconda3/bin/:" + os.environ["PATH"]

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import argparse
import sys
import seaborn as sns
import string

def get_chrmaxes(chromlist, endlist):
    chrmaxes = {}
    for i in zip(chromlist, endlist):
        if i[0] not in chrmaxes:
            chrmaxes[i[0]] = int(i[1])
        else:
            chrmaxes[i[0]] = max(int(i[1]), chrmaxes[i[0]])
    return(chrmaxes)

def get_chroffsets(chroms, chrmaxes, chromspace):
    chroffsets = {}
    mainoffset = 0
    for i in chroms:
        chroffsets[i] = mainoffset
        mainoffset = int(mainoffset) + int(chrmaxes[i]) + int(chromspace)
    return(chroffsets)

def get_start_offset(row, chroffsets):
    return(chroffsets[row['chrom']] + int(row['start']))

def get_end_offset(row, chroffsets):
    return(chroffsets[row['chrom']] + int(row['end']))

def get_color_col(catcol):
    categories = np.unique(catcol)
    built_in_colors = [ "#1b9e77", "#d95f02", "#7570b3", "#e7298a", "#66a61e"]
    colors = built_in_colors[:len(categories)]
    #colors = np.linspace(0, 1, len(categories))
    colordict = dict(zip(categories, colors))

    colorcol = catcol.apply(lambda x: colordict[x])
    return colorcol

def parse_all_data(inconns):
    alldatas = []
    letters = string.ascii_lowercase + string.ascii_uppercase
    for index, inconn in enumerate(inconns):
        alldata = pd.read_csv(i, sep="\t", header=0)
        inconn.close()

        chrlist = alldata["chrom"].to_list()
        endlist = alldata["end"].to_list()

        chroms = sorted(list(set([str(x) for x in chrlist])))
        chrmaxes = get_chrmaxes(chrlist, endlist)
        chroffsets = get_chroffsets(chroms, chrmaxes, chromspace)

        alldata["start_offset"] = alldata.apply(lambda row: get_start_offset(row, chroffsets), axis=1)
        alldata["end_offset"] = alldata.apply(lambda row: get_end_offset(row, chroffsets), axis=1)
        alldata["cross"] = [letters[index] for x in range(len(alldata.index))]
        alldatas.append(alldata)
    return(alldatas)

if __name__ == "__main__":

    parser = argparse.ArgumentParser("Visualize Hi-C pairing rates as a 2-d line plot.")
    parser.add_argument("input", nargs='*', help="Input file(s) generated by pairviz (default = stdin).")
    parser.add_argument("-o", "--output", help="output path (default = out.pdf).")
    parser.add_argument("-t", "--title", help="Title of plot (default = \"Pairing Rate\").")
    parser.add_argument("-p", "--proportion", help="If included, plot as a proportion of total reads in the region, rather than absolute (default = False).", action="store_true")
    parser.add_argument("-s", "--self", help="Also plot self-interactions (default = False).", action="store_true")
    parser.add_argument("-c", "--chromspace", help="bp of space to put between chromosomes in plot (default = 5000000).")
    parser.add_argument("-l", "--log", help="Log-scale the y-axis (default = False).", action="store_true")
    parser.add_argument("-i", "--stdin", help="take input from stdin along with other inputs.", action="store_true")

    args = parser.parse_args()

    output = "out.pdf"
    inconns = []
    if args.stdin or not input:
        inconns.append(sys.stdin)
    title = "Pairing Rate"
    proportion = False
    self = False
    chromspace = 5000000
    log = False
    pdf = False
    if args.output:
        output = args.output
        pdf = True
    if args.input:
        for i in args.input:
            inconns.append(open(i, "r"))
    if args.title:
        title = args.title
    if args.proportion:
        proportion = args.proportion
    if args.self:
        self = args.self
    if args.chromspace:
        chromspace = args.chromspace
    if args.log:
        log = args.log

    if proportion:
        my_y = 'pair_prop'
        alt_y = 'alt_prop'
    else:
        my_y = 'hits'
        alt_y = 'alt_hits'
    
    alldatas = parse_all_data(inconns)
    big_alldata = pd.concat(alldatas)
    m_alldata = pd.melt(big_alldata, id_vars=['chrom', 'start', 'end', 'start_offset', 'end_offset', 'cross'])
    if self:
        mm_alldata = m_alldata[m_alldata.apply(lambda x: x['variable'] in (my_y, alt_y), axis=1)]
    else:
        mm_alldata = m_alldata[m_alldata.apply(lambda x: x['variable'] in (my_y), axis=1)]
    mm_alldata['value'] = mm_alldata['value'].astype(float)

    myplot=sns.relplot(x='start_offset', y='value', data=mm_alldata, hue='cross', style = 'variable', kind='line')

    if log:
        myplot.fig.get_axes()[0].set_yscale('log')
    if pdf:
        plt.savefig(output)
    else:
        plt.show()

#chrom   start   end     hit_type        alt_hit_type    hits    alt_hits        pair_prop       alt_prop        pair_totprop    pair_totgoodprop        pair_totcloseprop       winsize winstep
#2L      0       10001   paired  self    9       26780   0.00033595879   0.99966404      5.4952663e-08   6.5204028e-08   6.5352044e-08   10001   1000
#2L      1000    11001   paired  self    9       26780   0.00033595879   0.99966404      5.4952663e-08   6.5204028e-08   6.5352044e-08   10001   1000
#chrom
#start
#end
#hit_type
#alt_hit_type
#hits
#alt_hits
#pair_prop
#alt_prop
#pair_totprop
#pair_totgoodprop
#pair_totcloseprop
#winsize
#winstep
#
# start_offset
# end_offset
